---
layout: post
title: "ECMAScript 6 overview"
date: 2014-10-19 12:45:46 +0200
comments: true
categories: JavaScript ECMAScript 6
description: "ECMAScript 6 Overview"
keywords: "miage, bordeaux, louis lainé, lainé, louis, javascript, nodejs, github, angularjs, ecmascript6"
---


After a great day at [bdx.io](bdx.io), i'm going to present you the newest features about ECMAScript 6. 


# Intro 

ES6 is the new version of JavaScript.

Will be release at mid 2015.

Let's see what's new ! 

# Class


```javascript 
class Car {
    // keyword which define the constructor and the class attributes
    constructor(name="Tesla"){ // ES6 take default values
        this.name = name;
    }

    toString() {
        return "name = " + this.name;
    }
}

let tesla = new Car();
tesla.toString() // name = Tesla

```

# Import / Export

It's very easy to create modules. 

## We have the mother class.

```javascript 
class Vehicule {
    constructor(name) {
        this.name = name;
    }
}

export default Vehicule;
```

## Inheritance

```javascript 

import Vehicule from './Vehicule'; // No .js extension

class Car extends Vehicule {
    constructor(name="Tesla") {
        super(name);
    }

    vroom() {
        console.log("Hey i'm a " + this.name + " car ! ");
    }
}

export default Car;
```


```javascript main.js

import Car from './Car';
let car = new Car();
car.vroom() 
```

# Fat arrow operator

```javascript 

// Before ES6 
var plop = function(name){ return "Plop " + name;  }; 

// With ES6
var plop = (name) => return "Plop " + name

console.log(plop("Louis")) // Plop Louis
```

#### Note 

- Can't be newable
- No _arguments_ parameters instead it's more about REST parameters.

```javascript 

var plop = (...name) => name.forEach(
        (somebody) => return "Plop " + somebody
    );

plop("Louis Lainé", "John Doe", "Toto");
```

Do not use the _Fat arrow_ to define objects function. 


# var vs let 

## Scope

var is scoped to the nearest function block (or global if outside a function block), and let is scoped to the nearest enclosing block (or global if outside any block), which can be smaller than a function block.

```javascript 
// let 
function foo() {
    // bar not visible out here.
    for(let bar = 0 ; bar < 10 ; ++bar){
        // bar is visible 
    }
    // bar is not visible
}
// var
function bar() {
    // bar is visible out here.
    for(var foo = 0 ; foo < 10 ; ++foo){
        // bar is visible 
    }
    // bar is visible
}
```

The let instruction also prevent you from redudant variables. 

Let declare variables at the beginning of the current block. If we re declare the variables again at the same level a _TypeError_ will be thrown.

```javascript 
if (x) {
  let toto;
  let toto; // TypeError thrown.
}
```


# Promises 

Promise have been around in JavaScript with some libraries as _Q_, _WinJS_, _when_ but they new arrived natively in JavaScript! 

```javascript 

let promise = new Promise((resolve, reject) => {
        // Make an async call
        
        if(/* everything is fine now */) {
            resolve("Yehee");
        }else{
            reject("Too bad");
        }
    });


// In an other file ... 
promise.
    then((data) => { 
        console.log(data);
    }).
    catch((error) => {
        console.log(error);
    });
```

Let's see an little example with an ajaxRequest for example.


```javascript 
function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // Make the request
    req.send();
  });
}

// Use 
get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.error("Failed!", error);
});
```


# Strings 

You can easily template string.

```javascript 

let firstName = "John"
  , lastName = "Coltrane";

console.log(`Hello, ${firstName} ${lastName}`); // Hello John Coltrane
```

We can also made some multi lines strings. 


```javascript

console.log(`
    Hello 
    ${firstName}
    ${lastName}
    `);
/*
    Hello
    John
    Coltrane
*/
```


# Mixin

## Object.assign 


```javascript 

let superman = {
    firstName: "Clark",
    lastName: "Kent"
};

let abilities = {
    fly(): => console.log("I can fly")
};

Object.assign(superman, abilities);

superman.fly(); // I can fly ! 
```

## Array.from

Before looping throw a _document.querySelector_ it was necessary to change first the result in an Array.

```javascript 

// Before ES6

var items = Array.prototype.slice.apply(document.querySelectorAll("h1"));
items.forEach(
    function(item) { 
        item.innerHTML = "Hello"; 
        }
    );

// With ES6
Array.from(document.querySelectorAll("h1"))
    .forEach((item) => item.innerHTML = "Hello")
```



# Maps 

Like in any other languages (or not) the maps arrived natively in JavaScript! 


```javascript

let map = new Map();

map.set("myKeyOne", { first:"firstValueOne", last:"lastValueOne" });
map.set("myKeyTwo", { first:"firstValueTwo", last:"lastValueTwo" });

console.log(map.size) // 2
console.log(map.has("myKeyOne")) // true 
console.log(map.get("myKeyTwo")) // { first:"firstValueTwo", last:"lastValueTwo" }


// We can also loop through the maps.
for (let key of map.keys()) {
  console.log("Key: %s", key);
}
/* Key: myKeyOne, Key: myKeyTwo */

for (let value of map.values()) {
  console.log("Value: %s %s", value.first, value.last);
}

```


# Conclusion 

We've seen all the newest features which are very exciting. 

In the next article we'll see how to code with ES6 using a transpiler called traceur.

